

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>array_split.split &mdash; array_split 0.6.xdev2-9-ge07abe3
 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="array_split 0.6.xdev2-9-ge07abe3
 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> array_split
          

          
          </a>

          
            
            
              <div class="version">
                0.6.xdev2

              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Read Me</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../about/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about/index.html#quick-start-example">Quick Start Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about/index.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about/index.html#requirements">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about/index.html#testing">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about/index.html#documentation">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about/index.html#latest-source-code">Latest source code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about/index.html#bug-reports">Bug Reports</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about/index.html#contributing">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about/index.html#license-information">License information</a></li>
</ul>
<p class="caption"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Terminology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html#parameter-categories">Parameter Categories</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html#import-statements-for-the-examples">Import statements for the examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html#array-split-shape-split-and-shapesplitter"><code class="samp docutils literal"><span class="pre">array_split</span></code>, <code class="samp docutils literal"><span class="pre">shape_split</span></code> and <code class="samp docutils literal"><span class="pre">ShapeSplitter</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html#splitting-by-number-of-tiles">Splitting by number of tiles</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#single-axis-number-of-tiles">Single axis number of tiles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#multiple-axes-number-of-tiles">Multiple axes number of tiles</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html#splitting-by-per-axis-cut-indices">Splitting by per-axis cut indices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#single-axis-cut-indices">Single axis cut indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#multiple-axes-cut-indices">Multiple axes cut indices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html#splitting-by-tile-shape">Splitting by tile shape</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html#splitting-by-maximum-bytes-per-tile">Splitting by maximum bytes per tile</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#tile-shape-upper-bound-constraint">Tile shape upper bound constraint</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#sub-tile-shape-constraint">Sub-tile shape constraint</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html#the-array-start-parameter">The <code class="samp docutils literal"><em><span class="pre">array_start</span></em></code> parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html#the-halo-parameter">The <code class="samp docutils literal"><em><span class="pre">halo</span></em></code> parameter</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../reference/array_split.html">The <code class="docutils literal"><span class="pre">array_split</span></code> Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/array_split.html#classes-and-functions">Classes and Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.shape_split.html">array_split.shape_split</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.array_split.html">array_split.array_split</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.ShapeSplitter.html">array_split.ShapeSplitter</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.__init__.html">array_split.ShapeSplitter.__init__</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.calculate_axis_split_extents.html">array_split.ShapeSplitter.calculate_axis_split_extents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.calculate_split.html">array_split.ShapeSplitter.calculate_split</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.calculate_split_by_indices_per_axis.html">array_split.ShapeSplitter.calculate_split_by_indices_per_axis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.calculate_split_by_split_size.html">array_split.ShapeSplitter.calculate_split_by_split_size</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.calculate_split_by_tile_max_bytes.html">array_split.ShapeSplitter.calculate_split_by_tile_max_bytes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.calculate_split_by_tile_shape.html">array_split.ShapeSplitter.calculate_split_by_tile_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.calculate_split_from_extents.html">array_split.ShapeSplitter.calculate_split_from_extents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.calculate_split_halos_from_extents.html">array_split.ShapeSplitter.calculate_split_halos_from_extents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.check_consistent_parameter_dimensions.html">array_split.ShapeSplitter.check_consistent_parameter_dimensions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.check_consistent_parameter_grouping.html">array_split.ShapeSplitter.check_consistent_parameter_grouping</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.check_split_parameters.html">array_split.ShapeSplitter.check_split_parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.check_tile_bounds_policy.html">array_split.ShapeSplitter.check_tile_bounds_policy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.convert_halo_to_array_form.html">array_split.ShapeSplitter.convert_halo_to_array_form</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.set_split_extents.html">array_split.ShapeSplitter.set_split_extents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.set_split_extents_by_indices_per_axis.html">array_split.ShapeSplitter.set_split_extents_by_indices_per_axis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.set_split_extents_by_split_size.html">array_split.ShapeSplitter.set_split_extents_by_split_size</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.set_split_extents_by_tile_max_bytes.html">array_split.ShapeSplitter.set_split_extents_by_tile_max_bytes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.set_split_extents_by_tile_shape.html">array_split.ShapeSplitter.set_split_extents_by_tile_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.ShapeSplitter.update_tile_extent_bounds.html">array_split.ShapeSplitter.update_tile_extent_bounds</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.array_itemsize.html">array_split.ShapeSplitter.array_itemsize</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.array_shape.html">array_split.ShapeSplitter.array_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.array_start.html">array_split.ShapeSplitter.array_start</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.halo.html">array_split.ShapeSplitter.halo</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.indices_per_axis.html">array_split.ShapeSplitter.indices_per_axis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.logger.html">array_split.ShapeSplitter.logger</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.max_tile_bytes.html">array_split.ShapeSplitter.max_tile_bytes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.max_tile_shape.html">array_split.ShapeSplitter.max_tile_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.split_begs.html">array_split.ShapeSplitter.split_begs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.split_ends.html">array_split.ShapeSplitter.split_ends</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.split_num_slices_per_axis.html">array_split.ShapeSplitter.split_num_slices_per_axis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.split_shape.html">array_split.ShapeSplitter.split_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.split_size.html">array_split.ShapeSplitter.split_size</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.sub_tile_shape.html">array_split.ShapeSplitter.sub_tile_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.tile_beg_min.html">array_split.ShapeSplitter.tile_beg_min</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.tile_bounds_policy.html">array_split.ShapeSplitter.tile_bounds_policy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.tile_end_max.html">array_split.ShapeSplitter.tile_end_max</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.tile_shape.html">array_split.ShapeSplitter.tile_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.ShapeSplitter.valid_tile_bounds_policies.html">array_split.ShapeSplitter.valid_tile_bounds_policies</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/array_split.html#attributes">Attributes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/array_split_split.html">The <code class="docutils literal"><span class="pre">array_split.split</span></code> Module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/array_split_split.html#classes-and-functions">Classes and Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.split.shape_factors.html">array_split.split.shape_factors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.split.calculate_num_slices_per_axis.html">array_split.split.calculate_num_slices_per_axis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.split.calculate_tile_shape_for_max_bytes.html">array_split.split.calculate_tile_shape_for_max_bytes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.split.convert_halo_to_array_form.html">array_split.split.convert_halo_to_array_form</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.split.ShapeSplitter.html">array_split.split.ShapeSplitter</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.__init__.html">array_split.split.ShapeSplitter.__init__</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.calculate_axis_split_extents.html">array_split.split.ShapeSplitter.calculate_axis_split_extents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.calculate_split.html">array_split.split.ShapeSplitter.calculate_split</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.calculate_split_by_indices_per_axis.html">array_split.split.ShapeSplitter.calculate_split_by_indices_per_axis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.calculate_split_by_split_size.html">array_split.split.ShapeSplitter.calculate_split_by_split_size</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.calculate_split_by_tile_max_bytes.html">array_split.split.ShapeSplitter.calculate_split_by_tile_max_bytes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.calculate_split_by_tile_shape.html">array_split.split.ShapeSplitter.calculate_split_by_tile_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.calculate_split_from_extents.html">array_split.split.ShapeSplitter.calculate_split_from_extents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.calculate_split_halos_from_extents.html">array_split.split.ShapeSplitter.calculate_split_halos_from_extents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.check_consistent_parameter_dimensions.html">array_split.split.ShapeSplitter.check_consistent_parameter_dimensions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.check_consistent_parameter_grouping.html">array_split.split.ShapeSplitter.check_consistent_parameter_grouping</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.check_split_parameters.html">array_split.split.ShapeSplitter.check_split_parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.check_tile_bounds_policy.html">array_split.split.ShapeSplitter.check_tile_bounds_policy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.convert_halo_to_array_form.html">array_split.split.ShapeSplitter.convert_halo_to_array_form</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.set_split_extents.html">array_split.split.ShapeSplitter.set_split_extents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.set_split_extents_by_indices_per_axis.html">array_split.split.ShapeSplitter.set_split_extents_by_indices_per_axis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.set_split_extents_by_split_size.html">array_split.split.ShapeSplitter.set_split_extents_by_split_size</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.set_split_extents_by_tile_max_bytes.html">array_split.split.ShapeSplitter.set_split_extents_by_tile_max_bytes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.set_split_extents_by_tile_shape.html">array_split.split.ShapeSplitter.set_split_extents_by_tile_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.update_tile_extent_bounds.html">array_split.split.ShapeSplitter.update_tile_extent_bounds</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.array_itemsize.html">array_split.split.ShapeSplitter.array_itemsize</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.array_shape.html">array_split.split.ShapeSplitter.array_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.array_start.html">array_split.split.ShapeSplitter.array_start</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.halo.html">array_split.split.ShapeSplitter.halo</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.indices_per_axis.html">array_split.split.ShapeSplitter.indices_per_axis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.logger.html">array_split.split.ShapeSplitter.logger</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.max_tile_bytes.html">array_split.split.ShapeSplitter.max_tile_bytes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.max_tile_shape.html">array_split.split.ShapeSplitter.max_tile_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.split_begs.html">array_split.split.ShapeSplitter.split_begs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.split_ends.html">array_split.split.ShapeSplitter.split_ends</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.split_num_slices_per_axis.html">array_split.split.ShapeSplitter.split_num_slices_per_axis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.split_shape.html">array_split.split.ShapeSplitter.split_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.split_size.html">array_split.split.ShapeSplitter.split_size</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.sub_tile_shape.html">array_split.split.ShapeSplitter.sub_tile_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.tile_beg_min.html">array_split.split.ShapeSplitter.tile_beg_min</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.tile_bounds_policy.html">array_split.split.ShapeSplitter.tile_bounds_policy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.tile_end_max.html">array_split.split.ShapeSplitter.tile_end_max</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.tile_shape.html">array_split.split.ShapeSplitter.tile_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split.ShapeSplitter.valid_tile_bounds_policies.html">array_split.split.ShapeSplitter.valid_tile_bounds_policies</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.split.shape_split.html">array_split.split.shape_split</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.split.array_split.html">array_split.split.array_split</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/array_split_split.html#attributes">Attributes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/array_split_split.html#utilities">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.split.is_scalar.html">array_split.split.is_scalar</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.split.is_sequence.html">array_split.split.is_sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.split.is_indices.html">array_split.split.is_indices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.split.pad_with_object.html">array_split.split.pad_with_object</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.split.pad_with_none.html">array_split.split.pad_with_none</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/array_split_split_test.html">The <code class="docutils literal"><span class="pre">array_split.split_test</span></code> Module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/array_split_split_test.html#classes">Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.split_test.SplitTest.html">array_split.split_test.SplitTest</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.__init__.html">array_split.split_test.SplitTest.__init__</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.addCleanup.html">array_split.split_test.SplitTest.addCleanup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.addTypeEqualityFunc.html">array_split.split_test.SplitTest.addTypeEqualityFunc</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.assertArraySplitEqual.html">array_split.split_test.SplitTest.assertArraySplitEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.countTestCases.html">array_split.split_test.SplitTest.countTestCases</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.debug.html">array_split.split_test.SplitTest.debug</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.defaultTestResult.html">array_split.split_test.SplitTest.defaultTestResult</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.doCleanups.html">array_split.split_test.SplitTest.doCleanups</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.id.html">array_split.split_test.SplitTest.id</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.run.html">array_split.split_test.SplitTest.run</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.setUp.html">array_split.split_test.SplitTest.setUp</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.setUpClass.html">array_split.split_test.SplitTest.setUpClass</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.shortDescription.html">array_split.split_test.SplitTest.shortDescription</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.skipTest.html">array_split.split_test.SplitTest.skipTest</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.subTest.html">array_split.split_test.SplitTest.subTest</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.tearDown.html">array_split.split_test.SplitTest.tearDown</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.tearDownClass.html">array_split.split_test.SplitTest.tearDownClass</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_array_split.html">array_split.split_test.SplitTest.test_array_split</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_calculate_num_slices_per_axis.html">array_split.split_test.SplitTest.test_calculate_num_slices_per_axis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_calculate_split_by_tile_max_bytes_1d.html">array_split.split_test.SplitTest.test_calculate_split_by_tile_max_bytes_1d</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_calculate_split_by_tile_shape_1d.html">array_split.split_test.SplitTest.test_calculate_split_by_tile_shape_1d</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_calculate_split_by_tile_shape_2d.html">array_split.split_test.SplitTest.test_calculate_split_by_tile_shape_2d</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_calculate_split_halos_from_extents.html">array_split.split_test.SplitTest.test_calculate_split_halos_from_extents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_calculate_split_with_array_start_1d.html">array_split.split_test.SplitTest.test_calculate_split_with_array_start_1d</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_calculate_split_with_array_start_2d.html">array_split.split_test.SplitTest.test_calculate_split_with_array_start_2d</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_calculate_split_with_halo_1d.html">array_split.split_test.SplitTest.test_calculate_split_with_halo_1d</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_calculate_split_with_halo_2d.html">array_split.split_test.SplitTest.test_calculate_split_with_halo_2d</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_calculate_split_with_halo_for_empty_tiles.html">array_split.split_test.SplitTest.test_calculate_split_with_halo_for_empty_tiles</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_calculate_tile_shape_for_max_bytes_1d.html">array_split.split_test.SplitTest.test_calculate_tile_shape_for_max_bytes_1d</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_calculate_tile_shape_for_max_bytes_2d.html">array_split.split_test.SplitTest.test_calculate_tile_shape_for_max_bytes_2d</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_convert_halo_to_array_form.html">array_split.split_test.SplitTest.test_convert_halo_to_array_form</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_multiple_parameter_groups_error.html">array_split.split_test.SplitTest.test_multiple_parameter_groups_error</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_pad_with_object.html">array_split.split_test.SplitTest.test_pad_with_object</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_properties.html">array_split.split_test.SplitTest.test_properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_shape_factors.html">array_split.split_test.SplitTest.test_shape_factors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_split_by_num_slices_1d.html">array_split.split_test.SplitTest.test_split_by_num_slices_1d</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_split_by_num_slices_2d_0_axis_elems.html">array_split.split_test.SplitTest.test_split_by_num_slices_2d_0_axis_elems</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_split_by_num_slices_2d_non_0_axis_elems.html">array_split.split_test.SplitTest.test_split_by_num_slices_2d_non_0_axis_elems</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.split_test.SplitTest.test_split_by_per_axis_indices.html">array_split.split_test.SplitTest.test_split_by_per_axis_indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split_test.SplitTest.logger.html">array_split.split_test.SplitTest.logger</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split_test.SplitTest.longMessage.html">array_split.split_test.SplitTest.longMessage</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.split_test.SplitTest.maxDiff.html">array_split.split_test.SplitTest.maxDiff</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/array_split_tests.html">The <code class="docutils literal"><span class="pre">array_split.tests</span></code> Module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/array_split_tests.html#classes-and-functions">Classes and Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.tests.MultiPlatformAnd23Checker.html">array_split.tests.MultiPlatformAnd23Checker</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.tests.MultiPlatformAnd23Checker.check_output.html">array_split.tests.MultiPlatformAnd23Checker.check_output</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.tests.MultiPlatformAnd23Checker.output_difference.html">array_split.tests.MultiPlatformAnd23Checker.output_difference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.tests.DocTestTestSuite.html">array_split.tests.DocTestTestSuite</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.tests.DocTestTestSuite.__init__.html">array_split.tests.DocTestTestSuite.__init__</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.tests.DocTestTestSuite.addTest.html">array_split.tests.DocTestTestSuite.addTest</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.tests.DocTestTestSuite.addTests.html">array_split.tests.DocTestTestSuite.addTests</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.tests.DocTestTestSuite.countTestCases.html">array_split.tests.DocTestTestSuite.countTestCases</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.tests.DocTestTestSuite.debug.html">array_split.tests.DocTestTestSuite.debug</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.tests.DocTestTestSuite.run.html">array_split.tests.DocTestTestSuite.run</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.tests.load_tests.html">array_split.tests.load_tests</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/array_split_logging.html">The <code class="docutils literal"><span class="pre">array_split.logging</span></code> Module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/array_split_logging.html#classes-and-functions">Classes and Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.logging.SplitStreamHandler.html">array_split.logging.SplitStreamHandler</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.__init__.html">array_split.logging.SplitStreamHandler.__init__</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.acquire.html">array_split.logging.SplitStreamHandler.acquire</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.addFilter.html">array_split.logging.SplitStreamHandler.addFilter</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.close.html">array_split.logging.SplitStreamHandler.close</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.createLock.html">array_split.logging.SplitStreamHandler.createLock</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.emit.html">array_split.logging.SplitStreamHandler.emit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.filter.html">array_split.logging.SplitStreamHandler.filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.flush.html">array_split.logging.SplitStreamHandler.flush</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.format.html">array_split.logging.SplitStreamHandler.format</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.get_name.html">array_split.logging.SplitStreamHandler.get_name</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.handle.html">array_split.logging.SplitStreamHandler.handle</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.handleError.html">array_split.logging.SplitStreamHandler.handleError</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.release.html">array_split.logging.SplitStreamHandler.release</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.removeFilter.html">array_split.logging.SplitStreamHandler.removeFilter</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.setFormatter.html">array_split.logging.SplitStreamHandler.setFormatter</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.setLevel.html">array_split.logging.SplitStreamHandler.setLevel</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.logging.SplitStreamHandler.set_name.html">array_split.logging.SplitStreamHandler.set_name</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.logging.SplitStreamHandler.name.html">array_split.logging.SplitStreamHandler.name</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.logging.SplitStreamHandler.terminator.html">array_split.logging.SplitStreamHandler.terminator</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.logging.initialise_loggers.html">array_split.logging.initialise_loggers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.logging.get_formatter.html">array_split.logging.get_formatter</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/array_split_unittest.html">The <code class="docutils literal"><span class="pre">array_split.unittest</span></code> Module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/array_split_unittest.html#classes-and-functions">Classes and Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.unittest.main.html">array_split.unittest.main</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.unittest.TestCase.html">array_split.unittest.TestCase</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.__init__.html">array_split.unittest.TestCase.__init__</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.addCleanup.html">array_split.unittest.TestCase.addCleanup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.addTypeEqualityFunc.html">array_split.unittest.TestCase.addTypeEqualityFunc</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertAlmostEqual.html">array_split.unittest.TestCase.assertAlmostEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertAlmostEquals.html">array_split.unittest.TestCase.assertAlmostEquals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertArraySplitEqual.html">array_split.unittest.TestCase.assertArraySplitEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertCountEqual.html">array_split.unittest.TestCase.assertCountEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertDictContainsSubset.html">array_split.unittest.TestCase.assertDictContainsSubset</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertDictEqual.html">array_split.unittest.TestCase.assertDictEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertEqual.html">array_split.unittest.TestCase.assertEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertEquals.html">array_split.unittest.TestCase.assertEquals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertFalse.html">array_split.unittest.TestCase.assertFalse</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertGreater.html">array_split.unittest.TestCase.assertGreater</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertGreaterEqual.html">array_split.unittest.TestCase.assertGreaterEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertIn.html">array_split.unittest.TestCase.assertIn</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertIs.html">array_split.unittest.TestCase.assertIs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertIsInstance.html">array_split.unittest.TestCase.assertIsInstance</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertIsNone.html">array_split.unittest.TestCase.assertIsNone</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertIsNot.html">array_split.unittest.TestCase.assertIsNot</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertIsNotNone.html">array_split.unittest.TestCase.assertIsNotNone</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertItemsEqual.html">array_split.unittest.TestCase.assertItemsEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertLess.html">array_split.unittest.TestCase.assertLess</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertLessEqual.html">array_split.unittest.TestCase.assertLessEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertListEqual.html">array_split.unittest.TestCase.assertListEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertLogs.html">array_split.unittest.TestCase.assertLogs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertMultiLineEqual.html">array_split.unittest.TestCase.assertMultiLineEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertNotAlmostEqual.html">array_split.unittest.TestCase.assertNotAlmostEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertNotAlmostEquals.html">array_split.unittest.TestCase.assertNotAlmostEquals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertNotEqual.html">array_split.unittest.TestCase.assertNotEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertNotEquals.html">array_split.unittest.TestCase.assertNotEquals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertNotIn.html">array_split.unittest.TestCase.assertNotIn</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertNotIsInstance.html">array_split.unittest.TestCase.assertNotIsInstance</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertNotRegex.html">array_split.unittest.TestCase.assertNotRegex</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertNotRegexpMatches.html">array_split.unittest.TestCase.assertNotRegexpMatches</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertRaises.html">array_split.unittest.TestCase.assertRaises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertRaisesRegex.html">array_split.unittest.TestCase.assertRaisesRegex</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertRaisesRegexp.html">array_split.unittest.TestCase.assertRaisesRegexp</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertRegex.html">array_split.unittest.TestCase.assertRegex</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertRegexpMatches.html">array_split.unittest.TestCase.assertRegexpMatches</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertSequenceEqual.html">array_split.unittest.TestCase.assertSequenceEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertSetEqual.html">array_split.unittest.TestCase.assertSetEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertTrue.html">array_split.unittest.TestCase.assertTrue</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertTupleEqual.html">array_split.unittest.TestCase.assertTupleEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertWarns.html">array_split.unittest.TestCase.assertWarns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assertWarnsRegex.html">array_split.unittest.TestCase.assertWarnsRegex</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.assert_.html">array_split.unittest.TestCase.assert_</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.countTestCases.html">array_split.unittest.TestCase.countTestCases</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.debug.html">array_split.unittest.TestCase.debug</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.defaultTestResult.html">array_split.unittest.TestCase.defaultTestResult</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.doCleanups.html">array_split.unittest.TestCase.doCleanups</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.fail.html">array_split.unittest.TestCase.fail</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.failIf.html">array_split.unittest.TestCase.failIf</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.failIfAlmostEqual.html">array_split.unittest.TestCase.failIfAlmostEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.failIfEqual.html">array_split.unittest.TestCase.failIfEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.failUnless.html">array_split.unittest.TestCase.failUnless</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.failUnlessAlmostEqual.html">array_split.unittest.TestCase.failUnlessAlmostEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.failUnlessEqual.html">array_split.unittest.TestCase.failUnlessEqual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.failUnlessRaises.html">array_split.unittest.TestCase.failUnlessRaises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.id.html">array_split.unittest.TestCase.id</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.run.html">array_split.unittest.TestCase.run</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.setUp.html">array_split.unittest.TestCase.setUp</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.setUpClass.html">array_split.unittest.TestCase.setUpClass</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.shortDescription.html">array_split.unittest.TestCase.shortDescription</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.skipTest.html">array_split.unittest.TestCase.skipTest</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.subTest.html">array_split.unittest.TestCase.subTest</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.tearDown.html">array_split.unittest.TestCase.tearDown</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/methods/array_split.unittest.TestCase.tearDownClass.html">array_split.unittest.TestCase.tearDownClass</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.unittest.TestCase.longMessage.html">array_split.unittest.TestCase.longMessage</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/generated/generated/attribs/array_split.unittest.TestCase.maxDiff.html">array_split.unittest.TestCase.maxDiff</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/array_split_license.html">The <code class="docutils literal"><span class="pre">array_split.license</span></code> Module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/array_split_license.html#license">License</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/array_split_license.html#copyright">Copyright</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/array_split_license.html#functions">Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.license.license.html">array_split.license.license</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.license.copyright.html">array_split.license.copyright</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/array_split.license.version.html">array_split.license.version</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/index.html">How to contribute</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../contributing/index.html#workflow">Workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing/index.html#coding-guidelines">Coding Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing/index.html#code-of-conduct">Code of Conduct</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">array_split</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>array_split.split</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for array_split.split</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">===================================</span>
<span class="sd">The :mod:`array_split.split` Module</span>
<span class="sd">===================================</span>

<span class="sd">.. currentmodule:: array_split.split</span>

<span class="sd">Defines array splitting functions and classes.</span>

<span class="sd">Classes and Functions</span>
<span class="sd">=====================</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree: generated/</span>

<span class="sd">   shape_factors - Compute *largest* factors of a given integer.</span>
<span class="sd">   calculate_num_slices_per_axis - Computes per-axis divisions for a multi-dimensional shape.</span>
<span class="sd">   calculate_tile_shape_for_max_bytes - Calculate a tile shape subject to max bytes restriction.</span>
<span class="sd">   convert_halo_to_array_form - converts halo argument to :samp:`(ndim, 2)` shaped array.</span>
<span class="sd">   ShapeSplitter - Splits a given shape into slices.</span>
<span class="sd">   shape_split - Splits a specified shape and returns :obj:`numpy.ndarray` of :obj:`slice` elements.</span>
<span class="sd">   array_split - Equivalent to :func:`numpy.array_split`.</span>

<span class="sd">Attributes</span>
<span class="sd">==========</span>

<span class="sd">.. autodata:: ARRAY_BOUNDS</span>
<span class="sd">.. autodata:: NO_BOUNDS</span>

<span class="sd">Utilities</span>
<span class="sd">=========</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree: generated/</span>

<span class="sd">   is_scalar - Return :samp:`True` if argument is numeric scalar.</span>
<span class="sd">   is_sequence - Return :samp:`True` if argument is a sequence.</span>
<span class="sd">   is_indices - Return :samp:`True` if argument is a sequence.</span>
<span class="sd">   pad_with_object - End pads a sequence with specified object.</span>
<span class="sd">   pad_with_none - End pads a sequence with :samp:`None` elements.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_np</span>
<span class="kn">from</span> <span class="nn">.license</span> <span class="k">import</span> <span class="n">license</span> <span class="k">as</span> <span class="n">_license</span><span class="p">,</span> <span class="n">copyright</span> <span class="k">as</span> <span class="n">_copyright</span><span class="p">,</span> <span class="n">version</span> <span class="k">as</span> <span class="n">_version</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">logging</span> <span class="k">as</span> <span class="n">_logging</span>

<span class="n">__copyright__</span> <span class="o">=</span> <span class="n">_copyright</span><span class="p">()</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="n">_version</span><span class="p">()</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Shane J. Latham&quot;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="n">_license</span><span class="p">()</span>


<div class="viewcode-block" id="is_scalar"><a class="viewcode-back" href="../../reference/generated/array_split.split.is_scalar.html#array_split.is_scalar">[docs]</a><span class="k">def</span> <span class="nf">is_scalar</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns :samp:`True` if argument :samp:`{obj}` is</span>
<span class="sd">    a numeric type.</span>

<span class="sd">    :type obj: :obj:`object`</span>
<span class="sd">    :param obj: Return :samp:`True` if this is a scalar.</span>
<span class="sd">    :rtype: :obj:`bool`</span>
<span class="sd">    :return: :samp:`True` if :samp:`{obj}` is a numeric scalar.</span>

<span class="sd">    Example::</span>

<span class="sd">       &gt;&gt;&gt; is_scalar(5)</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; is_scalar(2.0)</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; import numpy as np</span>
<span class="sd">       &gt;&gt;&gt; is_scalar(np.ones((10,), dtype=&quot;uint16&quot;)[0])</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; is_scalar([1, 2, 3])</span>
<span class="sd">       False</span>
<span class="sd">       &gt;&gt;&gt; is_scalar([i for i in range(0, 3)])</span>
<span class="sd">       False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;__int__&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;__long__&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_sequence"><a class="viewcode-back" href="../../reference/generated/array_split.split.is_sequence.html#array_split.is_sequence">[docs]</a><span class="k">def</span> <span class="nf">is_sequence</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns :samp:`True` if argument :samp:`{obj}` is</span>
<span class="sd">    a sequence (e.g. a :obj:`list` or :obj:`tuple`, etc).</span>

<span class="sd">    :type obj: :obj:`object`</span>
<span class="sd">    :param obj: Return :samp:`True` if this is a sequence.</span>
<span class="sd">    :rtype: :obj:`bool`</span>
<span class="sd">    :return: :samp:`True` if :samp:`{obj}` is a sequence.</span>

<span class="sd">    Example::</span>

<span class="sd">       &gt;&gt;&gt; is_sequence([1, 2, 3])</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; is_sequence([i for i in range(0, 3)])</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; is_sequence(5)</span>
<span class="sd">       False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">)</span>
        <span class="ow">or</span>
        <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;__getitem__&quot;</span><span class="p">)</span>
        <span class="ow">or</span>
        <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="is_indices"><a class="viewcode-back" href="../../reference/generated/array_split.split.is_indices.html#array_split.is_indices">[docs]</a><span class="k">def</span> <span class="nf">is_indices</span><span class="p">(</span><span class="n">indices_or_sections</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test for the :samp:`{indices_or_sections}` argument of :meth:`ShapeSplitter.__init__`</span>
<span class="sd">    to determine whether it is specifying *total number of tiles* or sequence of</span>
<span class="sd">    *cut* indices. Returns :samp:`True` if argument :samp:`{indices_or_sections}` is</span>
<span class="sd">    a sequence (e.g. a :obj:`list` or :obj:`tuple`, etc).</span>

<span class="sd">    :type indices_or_sections: :obj:`object`</span>
<span class="sd">    :param indices_or_sections: Return :samp:`True` if this is a sequence.</span>
<span class="sd">    :rtype: :obj:`bool`</span>
<span class="sd">    :return: :samp:`is_sequence({indices_or_sections})`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">indices_or_sections</span><span class="p">)</span></div>


<div class="viewcode-block" id="pad_with_object"><a class="viewcode-back" href="../../reference/generated/array_split.split.pad_with_object.html#array_split.pad_with_object">[docs]</a><span class="k">def</span> <span class="nf">pad_with_object</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">new_length</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns :samp:`sequence` :obj:`list` end-padded with :samp:`{obj}`</span>
<span class="sd">    elements so that the length of the returned list equals :samp:`{new_length}`.</span>

<span class="sd">    :type sequence: iterable</span>
<span class="sd">    :param sequence: Return *listified* sequence which has been end-padded.</span>
<span class="sd">    :type new_length: :obj:`int`</span>
<span class="sd">    :param new_length: The length of the returned list.</span>
<span class="sd">    :type obj: :obj:`object`</span>
<span class="sd">    :param obj: Object used as padding elements.</span>
<span class="sd">    :rtype: :obj:`list`</span>
<span class="sd">    :return: A :obj:`list` of length :samp:`{new_length}`.</span>
<span class="sd">    :raises ValueError: if :samp:`len({sequence}) &gt; {new_length})`.</span>

<span class="sd">    Example::</span>

<span class="sd">       &gt;&gt;&gt; pad_with_object([1, 2, 3], 5, obj=0)</span>
<span class="sd">       [1, 2, 3, 0, 0]</span>
<span class="sd">       &gt;&gt;&gt; pad_with_object([1, 2, 3], 5, obj=None)</span>
<span class="sd">       [1, 2, 3, None, None]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">new_length</span><span class="p">:</span>
        <span class="n">sequence</span> <span class="o">=</span> \
            <span class="nb">list</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">obj</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">new_length</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">new_length</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Got len(sequence)=</span><span class="si">%s</span><span class="s2"> which exceeds new_length=</span><span class="si">%s</span><span class="s2">&quot;</span>
            <span class="o">%</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">),</span> <span class="n">new_length</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">sequence</span></div>


<div class="viewcode-block" id="pad_with_none"><a class="viewcode-back" href="../../reference/generated/array_split.split.pad_with_none.html#array_split.pad_with_none">[docs]</a><span class="k">def</span> <span class="nf">pad_with_none</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">new_length</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns :samp:`sequence` :obj:`list` end-padded with :samp:`None`</span>
<span class="sd">    elements so that the length of the returned list equals :samp:`{new_length}`.</span>

<span class="sd">    :type sequence: iterable</span>
<span class="sd">    :param sequence: Return *listified* sequence which has been end-padded.</span>
<span class="sd">    :type new_length: :obj:`int`</span>
<span class="sd">    :param new_length: The length of the returned list.</span>
<span class="sd">    :rtype: :obj:`list`</span>
<span class="sd">    :return: A :obj:`list` of length :samp:`{new_length}`.</span>
<span class="sd">    :raises ValueError: if :samp:`len({sequence}) &gt; {new_length})`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">pad_with_object</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">new_length</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="shape_factors"><a class="viewcode-back" href="../../reference/generated/array_split.split.shape_factors.html#array_split.shape_factors">[docs]</a><span class="k">def</span> <span class="nf">shape_factors</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a :obj:`numpy.ndarray` of factors :samp:`f` such</span>
<span class="sd">    that :samp:`(len(f) == {dim}) and (numpy.product(f) == {n})`.</span>
<span class="sd">    The returned factors are as *square* (*cubic*, etc) as possible.</span>
<span class="sd">    For example::</span>

<span class="sd">       &gt;&gt;&gt; shape_factors(24, 1)</span>
<span class="sd">       array([24])</span>
<span class="sd">       &gt;&gt;&gt; shape_factors(24, 2)</span>
<span class="sd">       array([4, 6])</span>
<span class="sd">       &gt;&gt;&gt; shape_factors(24, 3)</span>
<span class="sd">       array([2, 3, 4])</span>
<span class="sd">       &gt;&gt;&gt; shape_factors(24, 4)</span>
<span class="sd">       array([2, 2, 2, 3])</span>
<span class="sd">       &gt;&gt;&gt; shape_factors(24, 5)</span>
<span class="sd">       array([1, 2, 2, 2, 3])</span>
<span class="sd">       &gt;&gt;&gt; shape_factors(24, 6)</span>
<span class="sd">       array([1, 1, 2, 2, 2, 3])</span>

<span class="sd">    :type n: :obj:`int`</span>
<span class="sd">    :param n: Integer which is factored into :samp:`{dim}` factors.</span>
<span class="sd">    :type dim: :obj:`int`</span>
<span class="sd">    :param dim: Number of factors.</span>
<span class="sd">    :rtype: :obj:`numpy.ndarray`</span>
<span class="sd">    :return: A :samp:`({dim},)` shaped array of integers which are factors of :samp:`{n}`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dim</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">dim</span><span class="p">)))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape_factors</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="n">f</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">break</span>

    <span class="n">factors</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span></div>


<div class="viewcode-block" id="calculate_tile_shape_for_max_bytes"><a class="viewcode-back" href="../../reference/generated/array_split.split.calculate_tile_shape_for_max_bytes.html#array_split.calculate_tile_shape_for_max_bytes">[docs]</a><span class="k">def</span> <span class="nf">calculate_tile_shape_for_max_bytes</span><span class="p">(</span>
    <span class="n">array_shape</span><span class="p">,</span>
    <span class="n">array_itemsize</span><span class="p">,</span>
    <span class="n">max_tile_bytes</span><span class="p">,</span>
    <span class="n">max_tile_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sub_tile_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">halo</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a tile shape :samp:`tile_shape`</span>
<span class="sd">    such that :samp:`numpy.product(tile_shape)*numpy.sum({array_itemsize}) &lt;= {max_tile_bytes}`.</span>
<span class="sd">    Also, if :samp:`{max_tile_shape} is not None`</span>
<span class="sd">    then :samp:`numpy.all(tile_shape &lt;= {max_tile_shape}) is True` and</span>
<span class="sd">    if :samp:`{sub_tile_shape} is not None`</span>
<span class="sd">    the :samp:`numpy.all((tile_shape % {sub_tile_shape}) == 0) is True`.</span>

<span class="sd">    :type array_shape: sequence of :obj:`int`</span>
<span class="sd">    :param array_shape: Shape of the array which is to be split into tiles.</span>
<span class="sd">    :type array_itemsize: :obj:`int`</span>
<span class="sd">    :param array_itemsize: The number of bytes per element of the array to be tiled.</span>
<span class="sd">    :type max_tile_bytes: :obj:`int`</span>
<span class="sd">    :param max_tile_bytes: The maximum number of bytes for the returned :samp:`tile_shape`.</span>
<span class="sd">    :type max_tile_shape: sequence of :obj:`int`</span>
<span class="sd">    :param max_tile_shape: Per axis maximum shapes for the returned :samp:`tile_shape`.</span>
<span class="sd">    :type sub_tile_shape: sequence of :obj:`int`</span>
<span class="sd">    :param sub_tile_shape: The returned :samp:`tile_shape` will be an even multiple</span>
<span class="sd">       of this sub-tile shape.</span>
<span class="sd">    :type halo: :obj:`int`, sequence of :obj:`int`, or :samp:`(len({array_shape}), 2)`</span>
<span class="sd">       shaped :obj:`numpy.ndarray`</span>
<span class="sd">    :param halo: How tiles are extended in each axis direction with *halo*</span>
<span class="sd">       elements. See :ref:`the-halo-parameter-examples` for meaning of :samp:`{halo}` values.</span>
<span class="sd">    :rtype: :obj:`numpy.ndarray`</span>
<span class="sd">    :return: A 1D array of shape :samp:`(len(array_shape),)` indicating a *tile shape*</span>
<span class="sd">       which will (approximately) uniformly divide the given :samp:`{array_shape}` into</span>
<span class="sd">       tiles (sub-arrays).</span>

<span class="sd">    Examples::</span>

<span class="sd">       &gt;&gt;&gt; from array_split.split import calculate_tile_shape_for_max_bytes</span>
<span class="sd">       &gt;&gt;&gt; calculate_tile_shape_for_max_bytes(</span>
<span class="sd">       ... array_shape=[512,],</span>
<span class="sd">       ... array_itemsize=1,</span>
<span class="sd">       ... max_tile_bytes=512</span>
<span class="sd">       ... )</span>
<span class="sd">       array([512])</span>
<span class="sd">       &gt;&gt;&gt; calculate_tile_shape_for_max_bytes(</span>
<span class="sd">       ... array_shape=[512,],</span>
<span class="sd">       ... array_itemsize=2,  # Doubling the itemsize halves the tile size.</span>
<span class="sd">       ... max_tile_bytes=512</span>
<span class="sd">       ... )</span>
<span class="sd">       array([256])</span>
<span class="sd">       &gt;&gt;&gt; calculate_tile_shape_for_max_bytes(</span>
<span class="sd">       ... array_shape=[512,],</span>
<span class="sd">       ... array_itemsize=1,</span>
<span class="sd">       ... max_tile_bytes=512-1  # tile shape will now be halved</span>
<span class="sd">       ... )</span>
<span class="sd">       array([256])</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">logger</span> <span class="o">=</span> <span class="n">_logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.calculate_tile_shape_for_max_bytes&quot;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;calculate_tile_shape_for_max_bytes: enter:&quot;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;array_shape=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">array_shape</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;array_itemsize=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">array_itemsize</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;max_tile_bytes=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">max_tile_bytes</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;max_tile_shape=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">max_tile_shape</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;sub_tile_shape=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sub_tile_shape</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;halo=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">halo</span><span class="p">)</span>

    <span class="n">array_shape</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
    <span class="n">array_itemsize</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">array_itemsize</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">max_tile_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_tile_shape</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array_shape</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">max_tile_shape</span> <span class="o">=</span> \
        <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">max_tile_shape</span><span class="p">,</span> <span class="n">array_shape</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">array_shape</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sub_tile_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sub_tile_shape</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">array_shape</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>

    <span class="n">sub_tile_shape</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sub_tile_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>

    <span class="n">halo</span> <span class="o">=</span> <span class="n">convert_halo_to_array_form</span><span class="p">(</span><span class="n">halo</span><span class="o">=</span><span class="n">halo</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">array_shape</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">array_shape</span> <span class="o">&lt;</span> <span class="n">sub_tile_shape</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Got array_shape=</span><span class="si">%s</span><span class="s2"> element less than corresponding sub_tile_shape=</span><span class="si">%s</span><span class="s2"> element.&quot;</span>
            <span class="o">%</span>
            <span class="p">(</span>
                <span class="n">array_shape</span><span class="p">,</span>
                <span class="n">sub_tile_shape</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;max_tile_shape=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">max_tile_shape</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;sub_tile_shape=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sub_tile_shape</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;halo=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">halo</span><span class="p">)</span>
    <span class="n">array_sub_tile_split_shape</span> <span class="o">=</span> <span class="p">((</span><span class="n">array_shape</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">sub_tile_shape</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">tile_sub_tile_split_shape</span> <span class="o">=</span> <span class="n">array_shape</span> <span class="o">//</span> <span class="n">sub_tile_shape</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tile_sub_tile_split_shape</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">tile_sub_tile_split_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> \
            <span class="nb">int</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="p">(</span><span class="n">max_tile_bytes</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">array_itemsize</span><span class="p">))</span>
                    <span class="o">-</span>
                    <span class="n">_np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">halo</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="o">/</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">sub_tile_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">))</span>

    <span class="n">tile_sub_tile_split_shape</span> <span class="o">=</span> \
        <span class="n">_np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
            <span class="n">tile_sub_tile_split_shape</span><span class="p">,</span>
            <span class="n">max_tile_shape</span> <span class="o">//</span> <span class="n">sub_tile_shape</span>
        <span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Pre loop: tile_sub_tile_split_shape=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">tile_sub_tile_split_shape</span><span class="p">)</span>

    <span class="n">current_axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">current_axis</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tile_sub_tile_split_shape</span><span class="p">))</span>
        <span class="ow">and</span>
        <span class="p">(</span>
            <span class="p">(</span>
                <span class="n">_np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">tile_sub_tile_split_shape</span> <span class="o">*</span> <span class="n">sub_tile_shape</span> <span class="o">+</span> <span class="n">_np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">halo</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                <span class="o">*</span>
                <span class="n">array_itemsize</span>
            <span class="p">)</span>
            <span class="o">&gt;</span>
            <span class="n">max_tile_bytes</span>
        <span class="p">)</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">current_axis</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tile_sub_tile_split_shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">tile_sub_tile_split_shape</span><span class="p">[</span><span class="n">current_axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">tile_sub_tile_split_shape</span><span class="p">[</span><span class="n">current_axis</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">(</span>
                    <span class="n">max_tile_bytes</span>
                    <span class="o">//</span>
                    <span class="p">(</span>
                        <span class="n">_np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span>
                            <span class="n">tile_sub_tile_split_shape</span> <span class="o">*</span>
                            <span class="n">sub_tile_shape</span> <span class="o">+</span>
                            <span class="n">_np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                                <span class="n">halo</span><span class="p">,</span>
                                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                        <span class="o">*</span>
                        <span class="n">array_itemsize</span>
                    <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">tile_sub_tile_split_shape</span><span class="p">[</span><span class="n">current_axis</span><span class="p">]</span> <span class="o">=</span> \
                <span class="nb">max</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">tile_sub_tile_split_shape</span><span class="p">[</span><span class="n">current_axis</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sub_tile_shape_h</span> <span class="o">=</span> <span class="n">sub_tile_shape</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">sub_tile_shape_h</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">current_axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">halo</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">current_axis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">tile_sub_tile_split_shape</span><span class="p">[</span><span class="n">current_axis</span><span class="p">]</span> <span class="o">=</span> \
                <span class="nb">int</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="p">(</span><span class="n">max_tile_bytes</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">array_itemsize</span><span class="p">))</span>
                        <span class="o">-</span>
                        <span class="n">_np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">halo</span><span class="p">[</span><span class="n">current_axis</span><span class="p">])</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">sub_tile_shape_h</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">current_axis</span><span class="p">])</span>
                    <span class="p">)</span>
                    <span class="o">/</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">sub_tile_shape_h</span><span class="p">))</span>
                <span class="p">))</span>
        <span class="n">current_axis</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Post loop: tile_sub_tile_split_shape=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">tile_sub_tile_split_shape</span><span class="p">)</span>
    <span class="n">tile_shape</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">array_shape</span><span class="p">,</span> <span class="n">tile_sub_tile_split_shape</span> <span class="o">*</span> <span class="n">sub_tile_shape</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;pre cannonicalise tile_shape=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">tile_shape</span><span class="p">)</span>

    <span class="n">tile_split_shape</span> <span class="o">=</span> <span class="p">((</span><span class="n">array_shape</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">tile_shape</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;tile_split_shape=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">tile_split_shape</span><span class="p">)</span>

    <span class="n">tile_shape</span> <span class="o">=</span> <span class="p">(((</span><span class="n">array_sub_tile_split_shape</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">tile_split_shape</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sub_tile_shape</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;post cannonicalise tile_shape=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">tile_shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tile_shape</span></div>


<div class="viewcode-block" id="calculate_num_slices_per_axis"><a class="viewcode-back" href="../../reference/generated/array_split.split.calculate_num_slices_per_axis.html#array_split.calculate_num_slices_per_axis">[docs]</a><span class="k">def</span> <span class="nf">calculate_num_slices_per_axis</span><span class="p">(</span><span class="n">num_slices_per_axis</span><span class="p">,</span> <span class="n">num_slices</span><span class="p">,</span> <span class="n">max_slices_per_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a :obj:`numpy.ndarray` (:samp:`return_array` say) where non-positive elements of</span>
<span class="sd">    the :samp:`{num_slices_per_axis}` sequence have been replaced with</span>
<span class="sd">    positive integer values such that :samp:`numpy.product(return_array) == num_slices`</span>
<span class="sd">    and::</span>

<span class="sd">       numpy.all(</span>
<span class="sd">           return_array[numpy.where(num_slices_per_axis &lt;= 0)]</span>
<span class="sd">           &lt;=</span>
<span class="sd">           max_slices_per_axis[numpy.where(num_slices_per_axis &lt;= 0)]</span>
<span class="sd">       ) is True</span>


<span class="sd">    :type num_slices_per_axis: sequence of :obj:`int`</span>
<span class="sd">    :param num_slices_per_axis: Constraint for per-axis sub-divisions.</span>
<span class="sd">       Non-positive elements indicate values to be replaced in the</span>
<span class="sd">       returned array. Positive values are identical to the corresponding</span>
<span class="sd">       element in the returned array.</span>
<span class="sd">    :type num_slices: integer</span>
<span class="sd">    :param num_slices: Indicates the number of slices (rectangular sub-arrays)</span>
<span class="sd">       formed by performing sub-divisions per axis. The returned array :samp:`return_array`</span>
<span class="sd">       has elements assigned such that :samp:`numpy.product(return_array) == {num_slices}`.</span>
<span class="sd">    :type max_slices_per_axis: sequence of :obj:`int` (or :samp:`None`)</span>
<span class="sd">    :param max_slices_per_axis: Constraint specifying maximum number of per-axis sub-divisions.</span>
<span class="sd">       If :samp:`None` defaults to :samp:`numpy.array([numpy.inf,]*len({num_slices_per_axis}))`.</span>
<span class="sd">    :rtype: :obj:`numpy.ndarray`</span>
<span class="sd">    :return: An array :samp:`return_array`</span>
<span class="sd">       such that :samp:`numpy.product(return_array) == num_slices`.</span>


<span class="sd">    Examples::</span>

<span class="sd">       &gt;&gt;&gt; from array_split.split import calculate_num_slices_per_axis</span>
<span class="sd">       &gt;&gt;&gt;</span>
<span class="sd">       &gt;&gt;&gt; calculate_num_slices_per_axis([0, 0, 0], 16)</span>
<span class="sd">       array([4, 2, 2])</span>
<span class="sd">       &gt;&gt;&gt; calculate_num_slices_per_axis([1, 0, 0], 16)</span>
<span class="sd">       array([1, 4, 4])</span>
<span class="sd">       &gt;&gt;&gt; calculate_num_slices_per_axis([1, 0, 0], 16, [2, 2, 16])</span>
<span class="sd">       array([1, 2, 8])</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">_logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="n">ret_array</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">num_slices_per_axis</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_slices_per_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_slices_per_axis</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_slices_per_axis</span><span class="p">))</span>

    <span class="n">max_slices_per_axis</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">max_slices_per_axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">max_slices_per_axis</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Got non-positive value in max_slices_per_axis=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">max_slices_per_axis</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ret_array</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">prd</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">ret_array</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ret_array</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)])</span>  <span class="c1"># returns 1 for zero-length array</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">num_slices</span> <span class="o">&lt;</span> <span class="n">prd</span><span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="n">num_slices</span> <span class="o">%</span> <span class="n">prd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="s2">&quot;Unable to construct grid of num_slices=</span><span class="si">%s</span><span class="s2"> elements from &quot;</span>
                    <span class="o">+</span>
                    <span class="s2">&quot;num_slices_per_axis=</span><span class="si">%s</span><span class="s2"> (with max_slices_per_axis=</span><span class="si">%s</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
                <span class="o">%</span>
                <span class="p">(</span><span class="n">num_slices</span><span class="p">,</span> <span class="n">num_slices_per_axis</span><span class="p">,</span> <span class="n">max_slices_per_axis</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">ridx</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ret_array</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">shape_factors</span><span class="p">(</span><span class="n">num_slices</span> <span class="o">//</span> <span class="n">prd</span><span class="p">,</span> <span class="n">ridx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="n">max_slices_per_axis</span><span class="p">[</span><span class="n">ridx</span><span class="p">]):</span>
            <span class="n">ret_array</span><span class="p">[</span><span class="n">ridx</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ridx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">max_slices_per_axis</span><span class="p">[</span><span class="n">ridx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]]:</span>
                    <span class="n">ret_array</span><span class="p">[</span><span class="n">ridx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">max_slices_per_axis</span><span class="p">[</span><span class="n">ridx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span>
                    <span class="n">prd</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">ret_array</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ret_array</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)])</span>
                    <span class="k">while</span> <span class="p">(</span><span class="n">num_slices</span> <span class="o">%</span> <span class="n">prd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ret_array</span><span class="p">[</span><span class="n">ridx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">prd</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">ret_array</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ret_array</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)])</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;ridx=</span><span class="si">%s</span><span class="s2">, f=</span><span class="si">%s</span><span class="s2">, ret_array=</span><span class="si">%s</span><span class="s2">, max_slices_per_axis=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">ridx</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">ret_array</span><span class="p">,</span> <span class="n">max_slices_per_axis</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">ret_array</span></div>


<span class="n">_array_shape_param_doc</span> <span class="o">=</span>\
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">:type array_shape: sequence of :obj:`int`</span>
<span class="sd">:param array_shape: The shape to be *split*.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">_array_start_param_doc</span> <span class="o">=</span>\
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">:type array_start: :samp:`None` or sequence of :obj:`int`</span>
<span class="sd">:param array_start: The start index. Defaults to :samp:`[0,]*len(array_shape)`.</span>
<span class="sd">   The array indexing extents are assumed to range from :samp:`{array_start}`</span>
<span class="sd">   to :samp:`{array_start} + {array_shape}`.</span>
<span class="sd">   See :ref:`the-array_start-parameter-examples` examples.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">_array_itemsize_param_doc</span> <span class="o">=</span>\
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">:type array_itemsize: int or sequence of :obj:`int`</span>
<span class="sd">:param array_itemsize: Number of bytes per array element.</span>
<span class="sd">   Only relevant when :samp:`{max_tile_bytes}` is specified.</span>
<span class="sd">   See :ref:`splitting-by-maximum-bytes-per-tile-examples` examples.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">_array_tile_bounds_policy_param_doc</span> <span class="o">=</span>\
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">:type tile_bounds_policy: :obj:`str`</span>
<span class="sd">:param tile_bounds_policy: Specifies whether tiles can extend beyond the array boundaries.</span>
<span class="sd">   Only relevant for halo values greater than one. If :samp:`{tile_bounds_policy}`</span>
<span class="sd">   is :data:`ARRAY_BOUNDS`</span>
<span class="sd">   then the calculated tiles will not extend beyond the array</span>
<span class="sd">   extents :samp:`{array_start}` and :samp:`{array_start} + {array_shape}`.</span>
<span class="sd">   If :samp:`{tile_bounds_policy}` is :data:`NO_BOUNDS`</span>
<span class="sd">   then the returned tiles will extend beyond</span>
<span class="sd">   the :samp:`{array_start}` and :samp:`{array_start} + {array_shape}` extend</span>
<span class="sd">   for positive :samp:`{halo}` values. See :ref:`the-halo-parameter-examples` examples.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">_ShapeSplitter__init__params_doc</span> <span class="o">=</span>\
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">:type indices_or_sections: :samp:`None`, :obj:`int` or sequence of :obj:`int`</span>
<span class="sd">:param indices_or_sections: If an integer, indicates the number of</span>
<span class="sd">    elements in the calculated *split* array. If a sequence, indicates</span>
<span class="sd">    the indices (per axis) at which the splits occur.</span>
<span class="sd">    See :ref:`splitting-by-number-of-tiles-examples` examples.</span>
<span class="sd">:type axis: :samp:`None`, :obj:`int` or sequence of :obj:`int`</span>
<span class="sd">:param axis: If an integer, indicates the axis which is to be split.</span>
<span class="sd">   If a sequence integers, indicates the number of slices per axis,</span>
<span class="sd">   i.e. if :samp:`{axis} = [3, 5]` then axis :samp:`0` is cut into</span>
<span class="sd">   3 slices and axis :samp:`1` is cut into 5 slices for a total</span>
<span class="sd">   of 15 (:samp:`3*5`) rectangular slices in the returned :samp:`(3, 5)`</span>
<span class="sd">   shaped split.</span>
<span class="sd">   See :ref:`splitting-by-number-of-tiles-examples` examples</span>
<span class="sd">   and :ref:`splitting-by-per-axis-split-indices-examples` examples.</span>
<span class="sd">%s%s</span>
<span class="sd">:type tile_shape: :samp:`None` or sequence of :obj:`int`</span>
<span class="sd">:param tile_shape: When not :samp:`None`, specifies explicit shape for tiles.</span>
<span class="sd">   Should be same length as :samp:`{array_shape}`.</span>
<span class="sd">   See :ref:`splitting-by-tile-shape-examples` examples.</span>
<span class="sd">:type max_tile_bytes: :samp:`None` or :obj:`int`</span>
<span class="sd">:param max_tile_bytes: The maximum number of bytes for calculated :samp:`tile_shape`.</span>
<span class="sd">   See :ref:`splitting-by-maximum-bytes-per-tile-examples` examples.</span>
<span class="sd">:type max_tile_shape: :samp:`None` or sequence of :obj:`int`</span>
<span class="sd">:param max_tile_shape: Per axis maximum shapes for the calculated :samp:`tile_shape`.</span>
<span class="sd">   Only relevant when :samp:`{max_tile_bytes}` is specified. Should be same length</span>
<span class="sd">   as :samp:`{array_shape}`.</span>
<span class="sd">   See :ref:`splitting-by-maximum-bytes-per-tile-examples` examples.</span>
<span class="sd">:type sub_tile_shape: :samp:`None` or sequence of :obj:`int`</span>
<span class="sd">:param sub_tile_shape: When not :samp:`None`, the calculated :samp:`tile_shape` will</span>
<span class="sd">    be an even multiple of this sub-tile shape. Only relevant when :samp:`{max_tile_bytes}`</span>
<span class="sd">    is specified. Should be same length as :samp:`{array_shape}`.</span>
<span class="sd">    See :ref:`splitting-by-maximum-bytes-per-tile-examples` examples.%s%s</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">_halo_param_doc</span> <span class="o">=</span>\
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">:type halo: :samp:`None`, :obj:`int`, sequence of :obj:`int`, or :samp:`(len({array_shape}), 2)`</span>
<span class="sd">   shaped :obj:`numpy.ndarray`</span>
<span class="sd">:param halo: How tiles are extended per axis in -ve and +ve directions with *halo*</span>
<span class="sd">   elements. See :ref:`the-halo-parameter-examples` examples.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#: Indicates that tiles are always within the array bounds.</span>
<span class="c1">#: See :ref:`the-halo-parameter-examples` examples.</span>
<span class="n">__ARRAY_BOUNDS</span> <span class="o">=</span> <span class="s2">&quot;array_bounds&quot;</span>


<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">ARRAY_BOUNDS</span><span class="p">():</span>  <span class="c1"># pylint: disable=invalid-name</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Indicates that tiles are always within the array bounds,</span>
<span class="sd">    resulting in tiles which have truncated halos.</span>
<span class="sd">    See :ref:`the-halo-parameter-examples` examples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">__ARRAY_BOUNDS</span>


<span class="c1">#: Indicates that tiles may extend beyond the array bounds.</span>
<span class="c1">#: See :ref:`the-halo-parameter-examples` examples.</span>
<span class="n">__NO_BOUNDS</span> <span class="o">=</span> <span class="s2">&quot;no_bounds&quot;</span>


<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">NO_BOUNDS</span><span class="p">():</span>  <span class="c1"># pylint: disable=invalid-name</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Indicates that tiles may have halos which extend beyond the array bounds.</span>
<span class="sd">    See :ref:`the-halo-parameter-examples` examples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">__NO_BOUNDS</span>


<div class="viewcode-block" id="convert_halo_to_array_form"><a class="viewcode-back" href="../../reference/generated/array_split.split.convert_halo_to_array_form.html#array_split.convert_halo_to_array_form">[docs]</a><span class="k">def</span> <span class="nf">convert_halo_to_array_form</span><span class="p">(</span><span class="n">halo</span><span class="p">,</span> <span class="n">ndim</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts the :samp:`{halo}` argument to a :samp:`(ndim, 2)`</span>
<span class="sd">    shaped array.</span>

<span class="sd">    :type halo: :samp:`None`, :obj:`int`, an :samp:`{ndim}` length sequence</span>
<span class="sd">        of :samp:`int` or :samp:`({ndim}, 2)` shaped array</span>
<span class="sd">        of :samp:`int`</span>
<span class="sd">    :param halo: Halo to be converted to :samp:`({ndim}, 2)` shaped array form.</span>
<span class="sd">    :type ndim: :obj:`int`</span>
<span class="sd">    :param ndim: Number of dimensions.</span>
<span class="sd">    :rtype: :obj:`numpy.ndarray`</span>
<span class="sd">    :return: A :samp:`({ndim}, 2)` shaped array of :obj:`numpy.int64` elements.</span>

<span class="sd">    Examples::</span>

<span class="sd">       &gt;&gt;&gt; convert_halo_to_array_form(halo=2, ndim=4)</span>
<span class="sd">       array([[2, 2],</span>
<span class="sd">              [2, 2],</span>
<span class="sd">              [2, 2],</span>
<span class="sd">              [2, 2]])</span>
<span class="sd">       &gt;&gt;&gt; convert_halo_to_array_form(halo=[0, 1, 2], ndim=3)</span>
<span class="sd">       array([[0, 0],</span>
<span class="sd">              [1, 1],</span>
<span class="sd">              [2, 2]])</span>
<span class="sd">       &gt;&gt;&gt; convert_halo_to_array_form(halo=[[0, 1], [2, 3], [3, 4]], ndim=3)</span>
<span class="sd">       array([[0, 1],</span>
<span class="sd">              [2, 3],</span>
<span class="sd">              [3, 4]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtyp</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">int64</span>
    <span class="k">if</span> <span class="n">halo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">halo</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ndim</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtyp</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">halo</span><span class="p">):</span>
        <span class="n">halo</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ndim</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtyp</span><span class="p">)</span> <span class="o">+</span> <span class="n">halo</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">halo</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)):</span>
        <span class="n">halo</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">halo</span><span class="p">,</span> <span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtyp</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">halo</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">halo</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">halo</span><span class="p">,</span> <span class="n">halo</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtyp</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">halo</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">halo</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtyp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">halo</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Got halo.shape=</span><span class="si">%s</span><span class="s2">, expecting halo.shape=(</span><span class="si">%s</span><span class="s2">, 2)&quot;</span>
            <span class="o">%</span>
            <span class="p">(</span><span class="n">halo</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">halo</span></div>


<div class="viewcode-block" id="ShapeSplitter"><a class="viewcode-back" href="../../reference/generated/array_split.split.ShapeSplitter.html#array_split.ShapeSplitter">[docs]</a><span class="k">class</span> <span class="nc">ShapeSplitter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements array shape splitting. There are three main (top-level) methods:</span>

<span class="sd">       :meth:`__init__`</span>
<span class="sd">          Initialisation of parameters which define the split.</span>
<span class="sd">       :meth:`set_split_extents`</span>
<span class="sd">          Calculates the per-axis indices for the cuts. Sets</span>
<span class="sd">          the :attr:`split_shape`, :attr:`split_begs`</span>
<span class="sd">          and :attr:`split_ends` attributes.</span>
<span class="sd">       :meth:`calculate_split`</span>
<span class="sd">          Calls :meth:`set_split_extents` followed</span>
<span class="sd">          by :meth:`calculate_split_from_extents` to</span>
<span class="sd">          return the :obj:`numpy.ndarray` of :obj:`tuple` elements (slices).</span>


<span class="sd">    Example::</span>

<span class="sd">       &gt;&gt;&gt; import numpy as np</span>
<span class="sd">       &gt;&gt;&gt; ary = np.arange(0, 10)</span>
<span class="sd">       &gt;&gt;&gt; splitter = ShapeSplitter(ary.shape, 3)</span>
<span class="sd">       &gt;&gt;&gt; split = splitter.calculate_split()</span>
<span class="sd">       &gt;&gt;&gt; split.shape</span>
<span class="sd">       (3,)</span>
<span class="sd">       &gt;&gt;&gt; split</span>
<span class="sd">       array([(slice(0, 4, None),), (slice(4, 7, None),), (slice(7, 10, None),)],</span>
<span class="sd">             dtype=[(&#39;0&#39;, &#39;O&#39;)])</span>
<span class="sd">       &gt;&gt;&gt; [ary[slyce] for slyce in split.flatten()]</span>
<span class="sd">       [array([0, 1, 2, 3]), array([4, 5, 6]), array([7, 8, 9])]</span>
<span class="sd">       &gt;&gt;&gt;</span>
<span class="sd">       &gt;&gt;&gt; splitter.split_shape # equivalent to split.shape above</span>
<span class="sd">       array([3])</span>
<span class="sd">       &gt;&gt;&gt; splitter.split_begs  # start indices for tile extents</span>
<span class="sd">       [array([0, 4, 7])]</span>
<span class="sd">       &gt;&gt;&gt; splitter.split_ends  # stop indices for tile extents</span>
<span class="sd">       [array([ 4,  7, 10])]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#: Class attribute for :obj:`logging.Logger` logging.</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">_logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.ShapeSplitter&quot;</span><span class="p">)</span>

    <span class="c1">#: Class attribute indicating list of valid values for :attr:`tile_bound_policy`.</span>
    <span class="c1">#: See :data:`ARRAY_BOUNDS` and :data:`NO_BOUNDS`.</span>
    <span class="n">valid_tile_bounds_policies</span> <span class="o">=</span> <span class="p">[</span><span class="n">ARRAY_BOUNDS</span><span class="p">,</span> <span class="n">NO_BOUNDS</span><span class="p">]</span>

<div class="viewcode-block" id="ShapeSplitter.__init__"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.__init__.html#array_split.ShapeSplitter.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">array_shape</span><span class="p">,</span>
        <span class="n">indices_or_sections</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">array_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">array_itemsize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">tile_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_tile_bytes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_tile_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sub_tile_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">halo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tile_bounds_policy</span><span class="o">=</span><span class="n">ARRAY_BOUNDS</span>
    <span class="p">):</span>
        <span class="c1"># Initialise *private* attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__array_shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__array_start</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__array_itemsize</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__indices_per_axis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__split_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__split_num_slices_per_axis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tile_shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__max_tile_bytes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__max_tile_shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__sub_tile_shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__halo</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tile_bounds_policy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tile_beg_min</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tile_end_max</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__split_shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__split_begs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__split_ends</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Now set properties from arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array_shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">array_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">array_start</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">array_start</span> <span class="o">=</span> <span class="n">array_start</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">array_itemsize</span> <span class="o">=</span> <span class="n">array_itemsize</span>

        <span class="n">indices_per_axis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">is_indices</span><span class="p">(</span><span class="n">indices_or_sections</span><span class="p">):</span>
            <span class="n">num_subarrays</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">indices_per_axis</span> <span class="o">=</span> <span class="n">indices_or_sections</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">((</span><span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
                <span class="ow">and</span>
                <span class="p">(</span><span class="ow">not</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">is_sequence</span><span class="p">(</span><span class="n">_e</span><span class="p">)</span> <span class="k">for</span> <span class="n">_e</span> <span class="ow">in</span> <span class="n">indices_or_sections</span><span class="p">]))</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># Make indices_per_axis a list of lists, so that</span>
                <span class="c1"># element 0 is a list of indices for axis 0</span>
                <span class="n">indices_per_axis</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">array_shape</span><span class="p">)</span>
                <span class="n">indices_per_axis</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices_or_sections</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices_per_axis</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">num_subarrays</span> <span class="o">=</span> <span class="n">indices_or_sections</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">indices_per_axis</span> <span class="o">=</span> <span class="n">indices_per_axis</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">split_size</span> <span class="o">=</span> <span class="n">num_subarrays</span>
        <span class="n">split_num_slices_per_axis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
                <span class="n">split_num_slices_per_axis</span> <span class="o">=</span> <span class="n">pad_with_object</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">split_num_slices_per_axis</span> <span class="o">=</span> <span class="n">pad_with_object</span><span class="p">([],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">split_num_slices_per_axis</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">split_num_slices_per_axis</span> <span class="o">=</span> <span class="n">split_num_slices_per_axis</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span> <span class="o">=</span> <span class="n">tile_shape</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_tile_bytes</span> <span class="o">=</span> <span class="n">max_tile_bytes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_tile_shape</span> <span class="o">=</span> <span class="n">max_tile_shape</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sub_tile_shape</span> <span class="o">=</span> <span class="n">sub_tile_shape</span>

        <span class="n">halo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_halo_to_array_form</span><span class="p">(</span><span class="n">halo</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">halo</span> <span class="o">=</span> <span class="n">halo</span>

        <span class="k">if</span> <span class="n">tile_bounds_policy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tile_bounds_policy</span> <span class="o">=</span> <span class="n">ARRAY_BOUNDS</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tile_bounds_policy</span> <span class="o">=</span> <span class="n">tile_bounds_policy</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tile_beg_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_start</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tile_end_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_start</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="ShapeSplitter.convert_halo_to_array_form"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.convert_halo_to_array_form.html#array_split.ShapeSplitter.convert_halo_to_array_form">[docs]</a>    <span class="k">def</span> <span class="nf">convert_halo_to_array_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">halo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the :samp:`{halo}` argument to a :samp:`({self}.array_shape.size, 2)`</span>
<span class="sd">        shaped array.</span>

<span class="sd">        :type halo: :samp:`None`, :obj:`int`, :samp:`self.array_shape.size` length sequence</span>
<span class="sd">            of :samp:`int` or :samp:`(self.array_shape.size, 2)` shaped array</span>
<span class="sd">            of :samp:`int`</span>
<span class="sd">        :param halo: Halo to be converted to :samp:`(len(self.array_shape), 2)` shaped array form.</span>
<span class="sd">        :rtype: :obj:`numpy.ndarray`</span>
<span class="sd">        :return: A :samp:`(len(self.array_shape), 2)` shaped array of :obj:`numpy.int64` elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">convert_halo_to_array_form</span><span class="p">(</span><span class="n">halo</span><span class="o">=</span><span class="n">halo</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">array_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The shape of the array which is to be split. A sequence of :obj:`int` indicating the</span>
<span class="sd">        per-axis sizes which are to be split.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_shape</span>

    <span class="nd">@array_shape</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">array_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array_shape</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__array_shape</span> <span class="o">=</span> <span class="n">array_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">array_start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The start index. A sequence of :obj:`int` indicating the start of indexing for</span>
<span class="sd">        the tile slices. Defaults to :samp:`numpy.zeros_like({self}.array_shape)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_start</span>

    <span class="nd">@array_start</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">array_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array_start</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__array_start</span> <span class="o">=</span> <span class="n">array_start</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">array_itemsize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of bytes per array element, see :attr:`max_tile_bytes`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_itemsize</span>

    <span class="nd">@array_itemsize</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">array_itemsize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array_itemsize</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__array_itemsize</span> <span class="o">=</span> <span class="n">array_itemsize</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indices_per_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The per-axis indices indicating the cuts for the split.</span>
<span class="sd">        A :obj:`list` of 1D :obj:`numpy.ndarray` objects such</span>
<span class="sd">        that :samp:`{self}.indices_per_axis[i]` indicates the</span>
<span class="sd">        cut positions for axis :samp:`i`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indices_per_axis</span>

    <span class="nd">@indices_per_axis</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">indices_per_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices_per_axis</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__indices_per_axis</span> <span class="o">=</span> <span class="n">indices_per_axis</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">split_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An :obj:`int` indicating the number of tiles in the calculated split.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__split_size</span>

    <span class="nd">@split_size</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">split_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__split_size</span> <span class="o">=</span> <span class="n">split_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">split_num_slices_per_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of slices per axis.</span>
<span class="sd">        A 1D :obj:`numpy.ndarray` of :obj:`int` indicating the number of slices (sections)</span>
<span class="sd">        per axis, so that :samp:`{self}.split_num_slices_per_axis[i]` is an integer</span>
<span class="sd">        indicating the number of sections along axis :samp:`i` in the calculated split.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__split_num_slices_per_axis</span>

    <span class="nd">@split_num_slices_per_axis</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">split_num_slices_per_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_num_slices_per_axis</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__split_num_slices_per_axis</span> <span class="o">=</span> <span class="n">split_num_slices_per_axis</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tile_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The shape of all tiles in the calculated split.</span>
<span class="sd">        A 1D :samp:`numpy.ndarray` of :obj:`int` indicating the per-axis</span>
<span class="sd">        number of elements for tiles in the calculated split.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tile_shape</span>

    <span class="nd">@tile_shape</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">tile_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile_shape</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tile_shape</span> <span class="o">=</span> <span class="n">tile_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_tile_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum number of bytes for any tile (including :attr:`halo`) in the returned split.</span>
<span class="sd">        An :obj:`int` which constrains the tile shape such that any tile</span>
<span class="sd">        from the computed split is no bigger than :samp:`{max_tile_bytes}`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_tile_bytes</span>

    <span class="nd">@max_tile_bytes</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">max_tile_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_tile_bytes</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__max_tile_bytes</span> <span class="o">=</span> <span class="n">max_tile_bytes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_tile_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Per-axis maximum sizes for calculated tiles.</span>
<span class="sd">        A 1D :samp:`numpy.ndarray` of :obj:`int` indicating the per-axis</span>
<span class="sd">        maximum number of elements for tiles in the calculated split.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_tile_shape</span>

    <span class="nd">@max_tile_shape</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">max_tile_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_tile_shape</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__max_tile_shape</span> <span class="o">=</span> <span class="n">max_tile_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sub_tile_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculated tile shape will be an integer multiple of this sub-tile shape.</span>
<span class="sd">        i.e. :samp:`(self.tile_shape[i] % self.sub_tile_shape[i]) == 0`,</span>
<span class="sd">        for :samp:`i in range(0, len(self.tile_shape))`.</span>
<span class="sd">        A 1D :samp:`numpy.ndarray` of :obj:`int` indicating sub-tile shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sub_tile_shape</span>

    <span class="nd">@sub_tile_shape</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">sub_tile_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_tile_shape</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__sub_tile_shape</span> <span class="o">=</span> <span class="n">sub_tile_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">halo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Per-axis -ve and +ve halo sizes for extending tiles to overlap with neighbouring tiles.</span>
<span class="sd">        A :samp:`(N, 2)` shaped array indicating the</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__halo</span>

    <span class="nd">@halo</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">halo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">halo</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__halo</span> <span class="o">=</span> <span class="n">convert_halo_to_array_form</span><span class="p">(</span><span class="n">halo</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tile_bounds_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A string indicating whether tile halo extents can extend beyond the array domain.</span>
<span class="sd">        Valid values are indicated by :attr:`valid_tile_bounds_policies`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tile_bounds_policy</span>

    <span class="nd">@tile_bounds_policy</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">tile_bounds_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile_bounds_policy</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tile_bounds_policy</span> <span class="o">=</span> <span class="n">tile_bounds_policy</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tile_beg_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The per-axis minimum index for :attr:`slice.start`. The per-axis lower bound for</span>
<span class="sd">        tile start indices. A 1D :obj:`numpy.ndarray`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tile_beg_min</span>

    <span class="nd">@tile_beg_min</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">tile_beg_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile_beg_min</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tile_beg_min</span> <span class="o">=</span> <span class="n">tile_beg_min</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tile_end_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The per-axis maximum index for :attr:`slice.stop`. The per-axis upper bound for</span>
<span class="sd">        tile stop indices. A 1D :obj:`numpy.ndarray`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tile_end_max</span>

    <span class="nd">@tile_end_max</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">tile_end_max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile_end_max</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tile_end_max</span> <span class="o">=</span> <span class="n">tile_end_max</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">split_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The shape of the calculated split array. Indicates the per-axis number</span>
<span class="sd">        of sections in the calculated split. A 1D :obj:`numpy.ndarray`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__split_shape</span>

    <span class="nd">@split_shape</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">split_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_shape</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__split_shape</span> <span class="o">=</span> <span class="n">split_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">split_begs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The list of per-axis start indices for :obj:`slice` objects.</span>
<span class="sd">        A :obj:`list` of 1D :obj:`numpy.ndarray` objects indicating</span>
<span class="sd">        the :attr:`slice.start` index for for tiles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__split_begs</span>

    <span class="nd">@split_begs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">split_begs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_begs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__split_begs</span> <span class="o">=</span> <span class="n">split_begs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">split_ends</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The list of per-axis stop indices for :obj:`slice` objects.</span>
<span class="sd">        A :obj:`list` of 1D :obj:`numpy.ndarray` objects indicating</span>
<span class="sd">        the :attr:`slice.stop` index for for tiles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__split_ends</span>

    <span class="nd">@split_ends</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">split_ends</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_ends</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__split_ends</span> <span class="o">=</span> <span class="n">split_ends</span>

<div class="viewcode-block" id="ShapeSplitter.check_tile_bounds_policy"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.check_tile_bounds_policy.html#array_split.ShapeSplitter.check_tile_bounds_policy">[docs]</a>    <span class="k">def</span> <span class="nf">check_tile_bounds_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raises :obj:`ValueError` if :attr:`tile_bounds_policy`</span>
<span class="sd">        is not in :samp:`[{self}.ARRAY_BOUNDS, {self}.NO_BOUNDS]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_bounds_policy</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid_tile_bounds_policies</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Got self.tile_bounds_policy=</span><span class="si">%s</span><span class="s2">, which is not in </span><span class="si">%s</span><span class="s2">.&quot;</span>
                <span class="o">%</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_bounds_policy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid_tile_bounds_policies</span><span class="p">)</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="ShapeSplitter.check_consistent_parameter_dimensions"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.check_consistent_parameter_dimensions.html#array_split.ShapeSplitter.check_consistent_parameter_dimensions">[docs]</a>    <span class="k">def</span> <span class="nf">check_consistent_parameter_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure that all parameter dimensions are consistent with</span>
<span class="sd">        the :attr:`array_shape` dimension.</span>

<span class="sd">        :raises ValueError: For inconsistent parameter dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices_per_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices_per_axis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Got len(self.indices_per_axis)=</span><span class="si">%s</span><span class="s2"> &gt; len(self.array_shape)=</span><span class="si">%s</span><span class="s2">, should be equal.&quot;</span>
                    <span class="o">%</span>
                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices_per_axis</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">))</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_num_slices_per_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_num_slices_per_axis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;Got len(self.split_num_slices_per_axis)=</span><span class="si">%s</span><span class="s2"> &gt; len(self.array_shape)=</span><span class="si">%s</span><span class="s2">,&quot;</span>
                        <span class="o">+</span>
                        <span class="s2">&quot; should be equal.&quot;</span>
                    <span class="p">)</span>
                    <span class="o">%</span>
                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_num_slices_per_axis</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">))</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Got len(self.tile_shape)=</span><span class="si">%s</span><span class="s2"> &gt; len(self.array_shape)=</span><span class="si">%s</span><span class="s2">, should be equal.&quot;</span>
                    <span class="o">%</span>
                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">))</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_tile_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_tile_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Got len(self.sub_tile_shape)=</span><span class="si">%s</span><span class="s2"> &gt; len(self.array_shape)=</span><span class="si">%s</span><span class="s2">, should be equal.&quot;</span>
                    <span class="o">%</span>
                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_tile_shape</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">))</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_tile_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_tile_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Got len(self.max_tile_shape)=</span><span class="si">%s</span><span class="s2"> &gt; len(self.array_shape)=</span><span class="si">%s</span><span class="s2">, should be equal.&quot;</span>
                    <span class="o">%</span>
                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_tile_shape</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">))</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_start</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Got len(self.array_start)=</span><span class="si">%s</span><span class="s2"> &gt; len(self.array_shape)=</span><span class="si">%s</span><span class="s2">, should be equal.&quot;</span>
                    <span class="o">%</span>
                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_start</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">))</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="ShapeSplitter.check_consistent_parameter_grouping"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.check_consistent_parameter_grouping.html#array_split.ShapeSplitter.check_consistent_parameter_grouping">[docs]</a>    <span class="k">def</span> <span class="nf">check_consistent_parameter_grouping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensures this object does not have conflicting groups of parameters.</span>

<span class="sd">        :raises ValueError: For conflicting or absent parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parameter_groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices_per_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parameter_groups</span><span class="p">[</span><span class="s2">&quot;indices_per_axis&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">{</span><span class="s2">&quot;self.indices_per_axis&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices_per_axis</span><span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_num_slices_per_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">parameter_groups</span><span class="p">[</span><span class="s2">&quot;split_size&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">{</span>
                    <span class="s2">&quot;self.split_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_size</span><span class="p">,</span>
                    <span class="s2">&quot;self.split_num_slices_per_axis&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_num_slices_per_axis</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parameter_groups</span><span class="p">[</span><span class="s2">&quot;tile_shape&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">{</span><span class="s2">&quot;self.tile_shape&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_tile_bytes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parameter_groups</span><span class="p">[</span><span class="s2">&quot;max_tile_bytes&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">{</span><span class="s2">&quot;self.max_tile_bytes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_tile_bytes</span><span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_tile_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;max_tile_bytes&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parameter_groups</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">parameter_groups</span><span class="p">[</span><span class="s2">&quot;max_tile_bytes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">parameter_groups</span><span class="p">[</span><span class="s2">&quot;max_tile_bytes&quot;</span><span class="p">][</span><span class="s2">&quot;self.max_tile_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_tile_shape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_tile_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;max_tile_bytes&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parameter_groups</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">parameter_groups</span><span class="p">[</span><span class="s2">&quot;max_tile_bytes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">parameter_groups</span><span class="p">[</span><span class="s2">&quot;max_tile_bytes&quot;</span><span class="p">][</span><span class="s2">&quot;self.sub_tile_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_tile_shape</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;parameter_groups=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">parameter_groups</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameter_groups</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">group_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">parameter_groups</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Got conflicting parameter groups specified, &quot;</span>
                <span class="o">+</span>
                <span class="s2">&quot;should only specify one group to define the split:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="o">+</span>
                <span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="p">(</span>
                                <span class="p">(</span><span class="s2">&quot;Group </span><span class="si">%18s</span><span class="s2">: &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">group_key</span><span class="p">))</span>
                                <span class="o">+</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">parameter_groups</span><span class="p">[</span><span class="n">group_key</span><span class="p">])</span>
                            <span class="p">)</span>
                            <span class="k">for</span> <span class="n">group_key</span> <span class="ow">in</span> <span class="n">group_keys</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameter_groups</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No split parameters specified, need parameters from one of the groups: &quot;</span>
                <span class="o">+</span>
                <span class="s2">&quot;&#39;indices_per_axis&#39;, &#39;split_size&#39;, &#39;tile_shape&#39; or &#39;max_tile_bytes&#39;&quot;</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="ShapeSplitter.check_split_parameters"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.check_split_parameters.html#array_split.ShapeSplitter.check_split_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">check_split_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensures this object has a state consistent with evaluating a split.</span>

<span class="sd">        :raises ValueError: For conflicting or absent parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_tile_bounds_policy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_consistent_parameter_dimensions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_consistent_parameter_grouping</span><span class="p">()</span></div>

<div class="viewcode-block" id="ShapeSplitter.update_tile_extent_bounds"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.update_tile_extent_bounds.html#array_split.ShapeSplitter.update_tile_extent_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">update_tile_extent_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the :attr:`tile_beg_min` and :attr:`tile_end_max`</span>
<span class="sd">        data members according to :attr:`tile_bounds_policy`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_bounds_policy</span> <span class="o">==</span> <span class="n">NO_BOUNDS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tile_beg_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_start</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">halo</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tile_end_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_start</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">halo</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_bounds_policy</span> <span class="o">==</span> <span class="n">ARRAY_BOUNDS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tile_beg_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_start</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tile_end_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_start</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span></div>

<div class="viewcode-block" id="ShapeSplitter.set_split_extents_by_indices_per_axis"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.set_split_extents_by_indices_per_axis.html#array_split.ShapeSplitter.set_split_extents_by_indices_per_axis">[docs]</a>    <span class="k">def</span> <span class="nf">set_split_extents_by_indices_per_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets split shape :attr:`split_shape` and</span>
<span class="sd">        split extents (:attr:`split_begs` and :attr:`split_ends`)</span>
<span class="sd">        from values in :attr:`indices_per_axis`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices_per_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Got None for self.indices_per_axis&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;self.array_shape=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;self.indices_per_axis=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices_per_axis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices_per_axis</span> <span class="o">=</span> \
            <span class="n">pad_with_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices_per_axis</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">))</span>

        <span class="c1"># Define the start and stop indices (extents) for each axis slice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices_per_axis</span><span class="p">)):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices_per_axis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">indices</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">[</span><span class="n">i</span><span class="p">]),),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># start and stop is the full width of the axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;self.indices_per_axis=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices_per_axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="ShapeSplitter.calculate_split_from_extents"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.calculate_split_from_extents.html#array_split.ShapeSplitter.calculate_split_from_extents">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_split_from_extents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns split calculated using extents obtained</span>
<span class="sd">        from :attr:`split_begs` and :attr:`split_ends`.</span>
<span class="sd">        All calls to calculate the split end up here to produce</span>
<span class="sd">        the :mod:`numpy` `structured array &lt;http://docs.scipy.org/doc/numpy/user/basics.rec.html&gt;`_</span>
<span class="sd">        of :obj:`tuple`-of-:obj:`slice` elements.</span>

<span class="sd">        :rtype: :obj:`numpy.ndarray`</span>
<span class="sd">        :return:</span>
<span class="sd">           A :mod:`numpy` `structured array &lt;http://docs.scipy.org/doc/numpy/user/basics.rec.html&gt;`_</span>
<span class="sd">           where each element is a :obj:`tuple` of :obj:`slice` objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;self.split_shape=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;self.split_begs=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;self.split_ends=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> \
            <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="nb">tuple</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="nb">slice</span><span class="p">(</span>
                                <span class="nb">max</span><span class="p">([</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">idx</span><span class="p">[</span><span class="n">d</span><span class="p">]]</span>
                                    <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_start</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">halo</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                                    <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">idx</span><span class="p">[</span><span class="n">d</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">idx</span><span class="p">[</span><span class="n">d</span><span class="p">]]),</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">tile_beg_min</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                                <span class="p">]),</span>
                                <span class="nb">min</span><span class="p">([</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">idx</span><span class="p">[</span><span class="n">d</span><span class="p">]]</span>
                                    <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_start</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                                    <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">halo</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                                    <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">idx</span><span class="p">[</span><span class="n">d</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">idx</span><span class="p">[</span><span class="n">d</span><span class="p">]]),</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">tile_end_max</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                                <span class="p">])</span>
                            <span class="p">)</span>
                            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span><span class="p">))</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span>
                    <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="n">_np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span>
                            <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span><span class="p">)),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span>
                        <span class="p">)</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">d</span><span class="p">,</span> <span class="s2">&quot;object&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span><span class="p">))]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="ShapeSplitter.calculate_split_halos_from_extents"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.calculate_split_halos_from_extents.html#array_split.ShapeSplitter.calculate_split_halos_from_extents">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_split_halos_from_extents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns :samp:`(self.ndim, 2)` shaped halo array elements indicating</span>
<span class="sd">        the halo for each split. Tiles on the boundary may have the halo trimmed</span>
<span class="sd">        to account for the :attr:`tile_bounds_policy`.</span>

<span class="sd">        :rtype: :obj:`numpy.ndarray`</span>
<span class="sd">        :return:</span>
<span class="sd">           A :mod:`numpy` `structured array &lt;http://docs.scipy.org/doc/numpy/user/basics.rec.html&gt;`_</span>
<span class="sd">           where each element is a :samp:`(self.ndim, 2)` shaped :obj:`numpy.ndarray`</span>
<span class="sd">           indicating the per-axis and per-direction number of halo elements for each tile</span>
<span class="sd">           in the split.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;self.split_shape=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;self.split_begs=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;self.split_ends=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> \
            <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="nb">tuple</span><span class="p">(</span>
                            <span class="p">(</span>
                                <span class="nb">min</span><span class="p">([</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">idx</span><span class="p">[</span><span class="n">d</span><span class="p">]]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_beg_min</span><span class="p">[</span><span class="n">d</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">halo</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                                    <span class="o">*</span>
                                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">idx</span><span class="p">[</span><span class="n">d</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">idx</span><span class="p">[</span><span class="n">d</span><span class="p">]])</span>
                                <span class="p">]),</span>
                                <span class="nb">min</span><span class="p">([</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">tile_end_max</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">idx</span><span class="p">[</span><span class="n">d</span><span class="p">]],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">halo</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                                    <span class="o">*</span>
                                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">idx</span><span class="p">[</span><span class="n">d</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">idx</span><span class="p">[</span><span class="n">d</span><span class="p">]])</span>
                                <span class="p">])</span>
                            <span class="p">)</span>
                            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span><span class="p">))</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span>
                    <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="n">_np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span>
                            <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span><span class="p">)),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span>
                        <span class="p">)</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">d</span><span class="p">,</span> <span class="s2">&quot;2int64&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span><span class="p">))]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="ShapeSplitter.calculate_split_by_indices_per_axis"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.calculate_split_by_indices_per_axis.html#array_split.ShapeSplitter.calculate_split_by_indices_per_axis">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_split_by_indices_per_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns split calculated using extents obtained</span>
<span class="sd">        from :attr:`indices_per_axis`.</span>

<span class="sd">        :rtype: :obj:`numpy.ndarray`</span>
<span class="sd">        :return:</span>
<span class="sd">           A :mod:`numpy` `structured array &lt;http://docs.scipy.org/doc/numpy/user/basics.rec.html&gt;`_</span>
<span class="sd">           where each element is a :obj:`tuple` of :obj:`slice` objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_split_extents_by_indices_per_axis</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_split_from_extents</span><span class="p">()</span></div>

<div class="viewcode-block" id="ShapeSplitter.calculate_axis_split_extents"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.calculate_axis_split_extents.html#array_split.ShapeSplitter.calculate_axis_split_extents">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_axis_split_extents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_sections</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divides :samp:`range(0, {size})` into (approximately) equal sized</span>
<span class="sd">        intervals. Returns :samp:`(begs, ends)` where :samp:`slice(begs[i], ends[i])`</span>
<span class="sd">        define the intervals for :samp:`i in range(0, {num_sections})`.</span>

<span class="sd">        :type num_sections: :obj:`int`</span>
<span class="sd">        :param num_sections: Divide  :samp:`range(0, {size})` into this</span>
<span class="sd">           many intervals (approximately) equal sized intervals.</span>
<span class="sd">        :type size: :obj:`int`</span>
<span class="sd">        :param size: Range for the subdivision.</span>
<span class="sd">        :rtype: :obj:`tuple`</span>
<span class="sd">        :return: Two element tuple :samp:`(begs, ends)`</span>
<span class="sd">           such that :samp:`slice(begs[i], ends[i])` define the</span>
<span class="sd">           intervals for :samp:`i in range(0, {num_sections})`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">section_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">//</span> <span class="n">num_sections</span>
        <span class="k">if</span> <span class="n">section_size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">begs</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">section_size</span> <span class="o">*</span> <span class="n">num_sections</span><span class="p">,</span> <span class="n">section_size</span><span class="p">)</span>
            <span class="n">rem</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">section_size</span> <span class="o">*</span> <span class="n">num_sections</span>
            <span class="k">if</span> <span class="n">rem</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rem</span><span class="p">):</span>
                    <span class="n">begs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">begs</span><span class="p">)</span>
            <span class="n">ends</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">begs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">ends</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">begs</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_sections</span><span class="p">)</span>
            <span class="n">begs</span><span class="p">[</span><span class="n">size</span><span class="p">:]</span> <span class="o">=</span> <span class="n">size</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="n">begs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ends</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">begs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">return</span> <span class="n">begs</span><span class="p">,</span> <span class="n">ends</span></div>

<div class="viewcode-block" id="ShapeSplitter.set_split_extents_by_split_size"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.set_split_extents_by_split_size.html#array_split.ShapeSplitter.set_split_extents_by_split_size">[docs]</a>    <span class="k">def</span> <span class="nf">set_split_extents_by_split_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets split shape :attr:`split_shape` and</span>
<span class="sd">        split extents (:attr:`split_begs` and :attr:`split_ends`)</span>
<span class="sd">        from values in :attr:`split_size` and :attr:`split_num_slices_per_axis`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_num_slices_per_axis</span><span class="p">])</span>
                <span class="ow">and</span>
                <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_num_slices_per_axis</span><span class="p">])</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">split_size</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_num_slices_per_axis</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;Got invalid self.split_num_slices_per_axis=</span><span class="si">%s</span><span class="s2">, all elements &quot;</span>
                        <span class="o">+</span>
                        <span class="s2">&quot;need to be integers greater than zero when self.split_size is None.&quot;</span>
                    <span class="p">)</span>
                    <span class="o">%</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">split_num_slices_per_axis</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Pre  cannonicalise: self.split_num_slices_per_axis=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split_num_slices_per_axis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_num_slices_per_axis</span> <span class="o">=</span> \
            <span class="n">calculate_num_slices_per_axis</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">split_num_slices_per_axis</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">split_size</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Post cannonicalise: self.split_num_slices_per_axis=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split_num_slices_per_axis</span><span class="p">)</span>
        <span class="c1"># Define the start and stop indices (extents) for each axis slice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_num_slices_per_axis</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_axis_split_extents</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="ShapeSplitter.calculate_split_by_split_size"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.calculate_split_by_split_size.html#array_split.ShapeSplitter.calculate_split_by_split_size">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_split_by_split_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns split calculated using extents obtained</span>
<span class="sd">        from :attr:`split_size` and :attr:`split_num_slices_per_axis`.</span>

<span class="sd">        :rtype: :obj:`numpy.ndarray`</span>
<span class="sd">        :return:</span>
<span class="sd">           A :mod:`numpy` `structured array &lt;http://docs.scipy.org/doc/numpy/user/basics.rec.html&gt;`_</span>
<span class="sd">           where each element is a :obj:`tuple` of :obj:`slice` objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_split_extents_by_split_size</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_split_from_extents</span><span class="p">()</span></div>

<div class="viewcode-block" id="ShapeSplitter.set_split_extents_by_tile_shape"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.set_split_extents_by_tile_shape.html#array_split.ShapeSplitter.set_split_extents_by_tile_shape">[docs]</a>    <span class="k">def</span> <span class="nf">set_split_extents_by_tile_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets split shape :attr:`split_shape` and</span>
<span class="sd">        split extents (:attr:`split_begs` and :attr:`split_ends`)</span>
<span class="sd">        from value of :attr:`tile_shape`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_shape</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_begs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split_ends</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>

<div class="viewcode-block" id="ShapeSplitter.calculate_split_by_tile_shape"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.calculate_split_by_tile_shape.html#array_split.ShapeSplitter.calculate_split_by_tile_shape">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_split_by_tile_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns split calculated using extents obtained</span>
<span class="sd">        from :attr:`tile_shape`.</span>

<span class="sd">        :rtype: :obj:`numpy.ndarray`</span>
<span class="sd">        :return:</span>
<span class="sd">           A :mod:`numpy` `structured array &lt;http://docs.scipy.org/doc/numpy/user/basics.rec.html&gt;`_</span>
<span class="sd">           where each element is a :obj:`tuple` of :obj:`slice` objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_split_extents_by_tile_shape</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_split_from_extents</span><span class="p">()</span></div>

<div class="viewcode-block" id="ShapeSplitter.set_split_extents_by_tile_max_bytes"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.set_split_extents_by_tile_max_bytes.html#array_split.ShapeSplitter.set_split_extents_by_tile_max_bytes">[docs]</a>    <span class="k">def</span> <span class="nf">set_split_extents_by_tile_max_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets split extents (:attr:`split_begs`</span>
<span class="sd">        and :attr:`split_ends`) calculated using</span>
<span class="sd">        from :attr:`max_tile_bytes`</span>
<span class="sd">        (and :attr:`max_tile_shape`, :attr:`sub_tile_shape`, :attr:`halo`).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span> <span class="o">=</span> \
            <span class="n">calculate_tile_shape_for_max_bytes</span><span class="p">(</span>
                <span class="n">array_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">array_shape</span><span class="p">,</span>
                <span class="n">array_itemsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">array_itemsize</span><span class="p">,</span>
                <span class="n">max_tile_bytes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_tile_bytes</span><span class="p">,</span>
                <span class="n">max_tile_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_tile_shape</span><span class="p">,</span>
                <span class="n">sub_tile_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_tile_shape</span><span class="p">,</span>
                <span class="n">halo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">halo</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_split_extents_by_tile_shape</span><span class="p">()</span></div>

<div class="viewcode-block" id="ShapeSplitter.calculate_split_by_tile_max_bytes"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.calculate_split_by_tile_max_bytes.html#array_split.ShapeSplitter.calculate_split_by_tile_max_bytes">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_split_by_tile_max_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns split calculated using extents obtained</span>
<span class="sd">        from :attr:`max_tile_bytes`</span>
<span class="sd">        (and :attr:`max_tile_shape`, :attr:`sub_tile_shape`, :attr:`halo`).</span>

<span class="sd">        :rtype: :obj:`numpy.ndarray`</span>
<span class="sd">        :return:</span>
<span class="sd">           A :mod:`numpy` `structured array &lt;http://docs.scipy.org/doc/numpy/user/basics.rec.html&gt;`_</span>
<span class="sd">           where each element is a :obj:`tuple` of :obj:`slice` objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_split_extents_by_tile_max_bytes</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_split_from_extents</span><span class="p">()</span></div>

<div class="viewcode-block" id="ShapeSplitter.set_split_extents"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.set_split_extents.html#array_split.ShapeSplitter.set_split_extents">[docs]</a>    <span class="k">def</span> <span class="nf">set_split_extents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets split extents (:attr:`split_begs`</span>
<span class="sd">        and :attr:`split_ends`) calculated using</span>
<span class="sd">        selected attributes set from :meth:`__init__`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_split_parameters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_tile_extent_bounds</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices_per_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_split_extents_by_indices_per_axis</span><span class="p">()</span>
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_num_slices_per_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_split_extents_by_split_size</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_split_extents_by_tile_shape</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_tile_bytes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_split_extents_by_tile_max_bytes</span><span class="p">()</span></div>

<div class="viewcode-block" id="ShapeSplitter.calculate_split"><a class="viewcode-back" href="../../reference/generated/generated/methods/array_split.split.ShapeSplitter.calculate_split.html#array_split.ShapeSplitter.calculate_split">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the split.</span>

<span class="sd">        :rtype: :obj:`numpy.ndarray`</span>
<span class="sd">        :return:</span>
<span class="sd">           A :mod:`numpy` `structured array &lt;http://docs.scipy.org/doc/numpy/user/basics.rec.html&gt;`_</span>
<span class="sd">           of dimension :samp:`len({self}.array_shape)`.</span>
<span class="sd">           Each element of the returned array is a :obj:`tuple`</span>
<span class="sd">           containing :samp:`len({self}.array_shape)` elements, with each element</span>
<span class="sd">           being a :obj:`slice` object. Each :obj:`tuple` defines a slice within</span>
<span class="sd">           the bounds :samp:`{self}.array_start - {self}.halo[:, 0]`</span>
<span class="sd">           to :samp:`{self}.array_start + {self}.array_shape + {self}.halo[:, 1]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_split_extents</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_split_from_extents</span><span class="p">()</span></div></div>


<span class="n">ShapeSplitter</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="p">])</span><span class="o">.</span><span class="fm">__init__</span><span class="o">.</span><span class="vm">__func__</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> \
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Initialises parameters which define a split.</span>


<span class="sd">%s</span>
<span class="sd">%s</span>

<span class="sd">.. seealso:: :ref:`array_split-examples`</span>

<span class="sd">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span>
    <span class="n">_array_shape_param_doc</span><span class="p">,</span>
    <span class="p">(</span>
        <span class="n">_ShapeSplitter__init__params_doc</span>
        <span class="o">%</span>
        <span class="p">(</span>
            <span class="n">_array_start_param_doc</span><span class="p">,</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">_array_itemsize_param_doc</span><span class="p">,</span>
            <span class="n">_halo_param_doc</span><span class="p">,</span>
            <span class="n">_array_tile_bounds_policy_param_doc</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>


<div class="viewcode-block" id="shape_split"><a class="viewcode-back" href="../../reference/generated/array_split.split.shape_split.html#array_split.shape_split">[docs]</a><span class="k">def</span> <span class="nf">shape_split</span><span class="p">(</span><span class="n">array_shape</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="s2">&quot;To be replaced.&quot;</span>
    <span class="k">return</span> \
        <span class="n">ShapeSplitter</span><span class="p">(</span>
            <span class="n">array_shape</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span><span class="o">.</span><span class="n">calculate_split</span><span class="p">()</span></div>


<span class="n">shape_split</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span>\
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Splits specified :samp:`{array_shape}` in tiles, returns array of :obj:`slice` tuples.</span>

<span class="sd">%s</span>
<span class="sd">%s</span>
<span class="sd">:rtype: :obj:`numpy.ndarray`</span>
<span class="sd">:return: Array of :obj:`tuple` objects. Each :obj:`tuple` element</span>
<span class="sd">   is a :obj:`slice` object so that each :obj:`tuple` defines</span>
<span class="sd">   a multi-dimensional slice of an array of shape :samp:`{array_shape}`.</span>

<span class="sd">.. seealso:: :func:`array_split.array_split`, :meth:`array_split.ShapeSplitter`,</span>
<span class="sd">   :ref:`array_split-examples`</span>


<span class="sd">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">_array_shape_param_doc</span><span class="p">,</span>
        <span class="p">(</span>
            <span class="n">_ShapeSplitter__init__params_doc</span>
            <span class="o">%</span>
            <span class="p">(</span>
                <span class="n">_array_start_param_doc</span><span class="p">,</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">_array_itemsize_param_doc</span><span class="p">,</span>
                <span class="n">_halo_param_doc</span><span class="p">,</span>
                <span class="n">_array_tile_bounds_policy_param_doc</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>


<div class="viewcode-block" id="array_split"><a class="viewcode-back" href="../../reference/generated/array_split.split.array_split.html#array_split.array_split">[docs]</a><span class="k">def</span> <span class="nf">array_split</span><span class="p">(</span>
    <span class="n">ary</span><span class="p">,</span>
    <span class="n">indices_or_sections</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">tile_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">max_tile_bytes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">max_tile_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sub_tile_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">halo</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="s2">&quot;To be replaced.&quot;</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="n">ary</span><span class="p">[</span><span class="n">slyce</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">slyce</span> <span class="ow">in</span>
        <span class="n">shape_split</span><span class="p">(</span>
            <span class="n">array_shape</span><span class="o">=</span><span class="n">ary</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">indices_or_sections</span><span class="o">=</span><span class="n">indices_or_sections</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">array_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">array_itemsize</span><span class="o">=</span><span class="n">ary</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,</span>
            <span class="n">tile_shape</span><span class="o">=</span><span class="n">tile_shape</span><span class="p">,</span>
            <span class="n">max_tile_bytes</span><span class="o">=</span><span class="n">max_tile_bytes</span><span class="p">,</span>
            <span class="n">max_tile_shape</span><span class="o">=</span><span class="n">max_tile_shape</span><span class="p">,</span>
            <span class="n">sub_tile_shape</span><span class="o">=</span><span class="n">sub_tile_shape</span><span class="p">,</span>
            <span class="n">halo</span><span class="o">=</span><span class="n">halo</span><span class="p">,</span>
            <span class="n">tile_bounds_policy</span><span class="o">=</span><span class="n">ARRAY_BOUNDS</span>
        <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="p">]</span></div>


<span class="n">array_split</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span>\
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Splits the specified array :samp:`{ary}` into sub-arrays, returns list of :obj:`numpy.ndarray`.</span>

<span class="sd">:type ary: :obj:`numpy.ndarray`</span>
<span class="sd">:param ary: Array which is split into sub-arrays.</span>
<span class="sd">%s</span>
<span class="sd">:rtype: :obj:`list`</span>
<span class="sd">:return: List of :obj:`numpy.ndarray` elements, where each element is</span>
<span class="sd">   a *slice* from :samp:`{ary}` (potentially an empty slice).</span>

<span class="sd">.. seealso:: :func:`array_split.shape_split`, :meth:`array_split.ShapeSplitter`,</span>
<span class="sd">   :ref:`array_split-examples`</span>


<span class="sd">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">_ShapeSplitter__init__params_doc</span>
        <span class="o">%</span>
        <span class="p">(</span>
            <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">_halo_param_doc</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;len(</span><span class="si">{array_shape}</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="s2">&quot;len(</span><span class="si">{ary}</span><span class="s2">.shape)&quot;</span><span class="p">),</span>
            <span class="s2">&quot;&quot;</span>
        <span class="p">)</span>
    <span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)]</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright  2017 The Australian National University.
.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.6.xdev2-9-ge07abe3',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>